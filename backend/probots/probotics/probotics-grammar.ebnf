@@grammar::Probotics
@@parseinfo::True

@@comments::/\/\*.*?\*\//
@@eol_comments::/(#|\/\/).*?$/

@@keyword::if
@@keyword::else
@@keyword::null
@@keyword::none


start = {expression | comment}* $ ;

expression::Expression =
           | addition
           | subtraction
           | term
           ;

addition::Addition = left:expression op:'+' ~ right:term ;
subtraction::Subtraction = left:expression op:'-' ~ right:term ;

term::Term =
     | multiplication
     | division
     | factor
     ;

multiplication::Multiplication = left:term op:'*' ~ right:factor ;
division::Division = left:term op:'/' ~ right:factor ;

factor::Factor =
       | subexpression
       | number
       | string
       | bool
       | null
       ;

subexpression::Subexpression = '(' ~ @:expression ')' ;

number::Number = /(0|[1-9][0-9]*)(\.[0-9]+)?/ ;

string::String = /("[^\"]*"|'[^\']*')/ ;

bool::Bool = "true" | "false" ;

null::Null = "null" | "none" ;

# It's not clear to me why comments must be explictly defined. The docs
# say the the skip rule (_) below will skip comments, but it doesn't seem to
comment::Comment =
       | eol_comment
       | block_comment
       ;
eol_comment = "#" ~ /[^\n]*/ | "//" ~ /[^\n]*/ ;
block_comment = /\/\*.*?\*\// ;

# Skip rule for EOL comments, block comments, and whitespace
_ = /#.*?$|\/\/.*?|\/\*.*?\*\/|\s+/ ;  # Skip EOL comments, block comments, and whitespace

(*
command_list = {command}+ ;

command = assignment
        | if_statement
        | while_loop
        | simple_command
        | expression
        ;

assignment = (symbol | property_access) ":=" ( expression | block | block_with_arguments ) ;

if_statement = "if" condition block {"else" if_statement | "else" block}* ;

while_loop = "while" condition block ;

block = "{" command_list "}" ;

block_with_arguments = "{" symbol_list newline command_list "}" ;

condition = expression [comparison_op expression] ;

comparison_op = "==" | "!=" | "<" | ">" | "<=" | ">=" ;

expression = left:term add_op:"+" ~ right:term
           | left:term sub_op:"-" ~ right:term
           | term ;

term = 
     | left:term mul_op:"*" ~ right:factor
     | left:term div_op:"/" ~ right:factor
     | factor
     ;

factor = property_access | atom ;

atom = symbol
     | string
     | number
     | "(" ~ @:expression ")"
     | call
     | bool
     | null
     ;


property_access = target:symbol "." ~ property:SYMBOL ;

SYMBOL = symbol ;

call = symbol "(" ~ {expression {"," expression}*}* ")" ;

simple_command = symbol {expression}* ;

symbol_list = symbol {"," symbol}* ;

@name
symbol = /[a-zA-Z_][a-zA-Z0-9_]*/ ;



*)