@@grammar::Probotics
@@parseinfo::True

@@comments::/\/\*(?s:.*?)\*\//
@@eol_comments::/(#|\/\/)[^\n]*$/

@@keyword::break
@@keyword::else
@@keyword::False
@@keyword::false
@@keyword::if
@@keyword::next
@@keyword::None
@@keyword::none
@@keyword::null
@@keyword::True
@@keyword::true
@@keyword::while


start = {statement | comment}* $;

statement::Statement = 
     call |
     if_statement |
     while_loop |
     break |
     next |
     expression
     ;

expression::Expression = 
     assignment |
     addition |
     subtraction |
     term
     ;

assignment::Assignment = target:assignable ":=" ~ value:(block |expression) ;

assignable::Assignable = symbol ;

addition::Addition = left:expression op:'+' ~ right:term ;
subtraction::Subtraction = left:expression op:'-' ~ right:term ;

term::Term =
     multiplication |
     division |
     condition |
     factor
     ;

multiplication::Multiplication = left:term op:'*' ~ right:factor ;
division::Division = left:term op:'/' ~ right:factor ;

factor::Factor =
     subexpression |
     atom |
     symbol
     ;

subexpression = '(' ~ @:expression ')' ;

atom::Atom =
     bool |
     null |
     number |
     string
     ;

number::Number = /(0|[1-9][0-9]*)(\.[0-9]+)?/ ;

string::String = /("[^\"]*"|'[^\']*')/ ;

bool::Bool = "true" | "True" | "False" | "false" ;

null::Null = "null" | "none" | "None";

@name
symbol::Symbol = /[a-zA-Z_][a-zA-Z0-9_]*/ ;

call::Call = command:symbol LPAREN ~ args:",".{expression}* rparen ;
LPAREN = '(' ;
rparen = ')' ;

#bare_command::BareCommand = command:symbol ~ argument:{expression}+ ;

if_statement::IfStatement = "if" ~ condition:expression block:block else_chain:["else" ~ (else_block:block|if_statement)] ;

while_loop::WhileLoop = "while" ~ condition:expression block:block ;

block::Block = "{" ~ statements:{statement | comment}* "}" ;

condition::Condition = left:term op:comparison_op ~ right:factor ;

comparison_op = /={1,3}/ | /!={1,2}/ | "<=" | ">=" | "<" | ">" ;

break::Break = "break" ;
next::Next = "next" ;

# It's not clear to me why comments must be explicitly defined. The docs
# say the the skip rule (_) below will skip comments, but it doesn't seem to
comment::Comment =
     eol_comment |
     block_comment
     ;
eol_comment = /(#|\/\/)[^\n]*/ ;
block_comment = /\/\*(?s:.*?)\*\// ;

NEWLINE::NEWLINE = /[\r\n]+/ ;

# Skip rule for EOL comments, block comments, and whitespace
_ = /#.*|\/\/.*|\/\*(?s:.*?)\*\/|\s+/ ;  # Skip EOL comments, block comments, and whitespace

(*



block_with_arguments = "{" symbol_list newline command_list "}" ;


property_access = target:symbol "." ~ property:SYMBOL ;



symbol_list = symbol {"," symbol}* ;



*)