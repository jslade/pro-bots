@@grammar::Probotics
@@parseinfo::True

@@comments::/\/\*(?s:.*?)\*\//
@@eol_comments::/(#|\/\/)[^\n]*$/

@@keyword::else
@@keyword::False
@@keyword::false
@@keyword::if
@@keyword::None
@@keyword::none
@@keyword::null
@@keyword::True
@@keyword::true


start = {statement | comment}* $;

statement::Statement = 
     expression
     ;

expression::Expression = 
     assignment |
     addition |
     subtraction |
     term
     ;

assignment::Assignment = target:assignable ":=" ~ value:expression ;

assignable::Assignable = symbol ;

addition::Addition = left:expression op:'+' ~ right:term ;
subtraction::Subtraction = left:expression op:'-' ~ right:term ;

term::Term =
     multiplication |
     division |
     factor
     ;

multiplication::Multiplication = left:term op:'*' ~ right:factor ;
division::Division = left:term op:'/' ~ right:factor ;

factor::Factor =
     subexpression |
     atom |
     symbol
     ;

subexpression = '(' ~ @:expression ')' ;

atom::Atom =
     bool |
     null |
     number |
     string
     ;

number::Number = /(0|[1-9][0-9]*)(\.[0-9]+)?/ ;

string::String = /("[^\"]*"|'[^\']*')/ ;

bool::Bool = "true" | "True" | "False" | "false" ;

null::Null = "null" | "none" | "None";

@name
symbol::Symbol = !bool !null /[a-zA-Z_][a-zA-Z0-9_]*/ ;

#bare_command::BareCommand = command:symbol ~ argument:{expression}+ ;

# It's not clear to me why comments must be explicitly defined. The docs
# say the the skip rule (_) below will skip comments, but it doesn't seem to
comment::Comment =
     eol_comment |
     block_comment
     ;
eol_comment = /(#|\/\/)[^\n]*/ ;
block_comment = /\/\*(?s:.*?)\*\// ;

NEWLINE::NEWLINE = /[\r\n]+/ ;

# Skip rule for EOL comments, block comments, and whitespace
_ = /#.*|\/\/.*|\/\*(?s:.*?)\*\/|\s+/ ;  # Skip EOL comments, block comments, and whitespace

(*

if_statement = "if" condition block {"else" if_statement | "else" block}* ;

while_loop = "while" condition block ;

block = "{" command_list "}" ;

block_with_arguments = "{" symbol_list newline command_list "}" ;

condition = expression [comparison_op expression] ;

comparison_op = "==" | "!=" | "<" | ">" | "<=" | ">=" ;

property_access = target:symbol "." ~ property:SYMBOL ;


call = symbol "(" ~ {expression {"," expression}*}* ")" ;


symbol_list = symbol {"," symbol}* ;



*)